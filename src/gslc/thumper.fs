module thumper
open System.IO
open Amyris.Bio.utils
open Amyris.Bio.biolib
open commonTypes
open parseTypes
open pragmaTypes


open System
open System.Xml

open ryse
open shared
open markers
open constants
open uri

open sbolExample

// TODO: this probably belongs somewhere else.
let schemaLocation = "http://thumper.amyris.local"

/// Parts specific to keeping interactions with thumper cool
let thumperRabitNameLength = 600 // See also commonTypes maxNameLen
type MarkerSet = string

// ID 	Type/Breed 	Direction 	5' link 	3' link 	Insert Name 	Species 	Sequence Name 	
// Description 	5' primer 	3' primer 	IF Primer 	IR Primer 	DNA Sequence 	AA Sequence 	Notes
type Rabit = {
    id: int;
    extId: string option;
    breed: string;
    direction: Orientation;
    fiveLink: string;
    threeLink: string; 
    name: string; 
    species: string;
    seqName: string;
    desc: string; 
    fivePrimer: Primer;
    threePrimer: Primer;
    IFPrimer: Primer;
    IRPrimer: Primer;
    dnaSeq: char array;
    aaSeq: string; 
    notes: string;
    dnaSources: string list}
with
    /// Invert rabit direction, a hairy operation indeed.
    member x.flip() =
        {x with 
            dnaSeq = revComp x.dnaSeq;
            threePrimer = x.fivePrimer; // since primers were already antiparallel, they don't get revcompd
            fivePrimer = x.threePrimer;
            direction =
                match x.direction with
                | FWD -> REV
                | REV -> FWD

            // Don't flip these now... grrr thumper conventions.
            // Scratch that, do flip these now.  IF and F should point in the same direction.

            // These were strand specific already but Fwd/Rev swap roles
            IFPrimer = x.IRPrimer;
            IRPrimer = x.IFPrimer;
            fiveLink = x.threeLink;
            threeLink = x.fiveLink

            name = 
                let nameFlip (s:string) = 
                    if x.extId.IsNone then
                        // We autogenerated this rabit name based on part orientation,
                        // now the rabit will be built in reverse we should adjust name
                        //if s.StartsWith("!") then s.Substring(1) else "!"+s
                        s
                    else
                        // We imported this name from outside, and plan to just incorporate by
                        // reference.  Don't mess up the name.  Assume user has used rabit in right
                        // context or else it won't survive thumper validation
                        s
                if x.name.Contains(";") then
                    x.name.Split([| ';' |]) 
                    |> List.ofArray |> List.rev 
                    |> List.map (nameFlip) 
                    |> fun subparts -> String.Join(";",subparts)
                else nameFlip x.name       
        }
    /// Get Rabit "signature", a "unique" identification.
    member x.signature() = (x.name, x.breed, x.fiveLink, x.threeLink, x.dnaSeq)

    member x.DumpPrimers() =
        sprintf "5tail %s\n5body %s\n3tail %s\n3body %s" 
            (x.fivePrimer.tail |> arr2seq)
            (x.fivePrimer.body |> arr2seq)
            (x.threePrimer.tail |> arr2seq)
            (x.threePrimer.body |> arr2seq)

    member x.Body() = x.dnaSeq |> format60

/// Attempt to guess rabit breed
let estBreed (parts:DNASlice list) =
    match
        parts
        |> List.choose (fun p -> p.pragmas.TryGetValues("breed"))
        |> List.concat
        with
    | [breed] | breed::_ -> breed
    | [] ->
        let breeds =
            parts |> List.map (fun p -> p.breed)
            |> List.filter (fun p ->
                match p with 
                | B_LINKER -> false
                | B_VIRTUAL -> false
                | _ -> true )
        match breeds with
        | [B_PROMOTER] -> "P"
        | [B_TERMINATOR] -> "T"
        | [B_UPSTREAM] -> "U"
        | [B_DOWNSTREAM] -> "D"
        | [B_MARKER] -> "M"
        | [B_GST ] -> "GsT"
        | [B_GS ; B_TERMINATOR] -> "GsT"
        | [B_PROMOTER ; B_GST ] -> "PGsT"
        | [B_PROMOTER ; B_GS ] -> "PGs"
        | [B_FUSABLEORF] -> "G"
        | _ -> "X"

type StitchOut = {sId: int; rabits: Rabit list}

type MegastitchIn = {rabit1: Rabit list; rabit2: Rabit list; name: string}   
type MegastitchOut = {msId: int; a: StitchOut; b: StitchOut; name: string}   

/// Remove actual linker sequences, because Thumper is going to add those back in.
let trimRyseLinkers (ryseLinkers:Map<string,RYSELinker>) (r':Rabit) =

    // linker5 and linker3 are the actual DNA sequences of the linkers
    let linker5 = ryseLinkers.[r'.fiveLink]   
    let linker3 = ryseLinkers.[r'.threeLink]

    // len3 and len5 are the full lengths of the linkers
    let len5 = linker5.dna.Length  
    let len3 = linker3.dna.Length

    // Actual ryse linker in the primer might be shorter if we chopped some of the ryse
    // linker off as a compromise for melting temp considerations

    // Actual primer tail might be longer than the linker as well if an overzealous
    // primer design algorithm optimized annealing too well.
    let getPrimerTail primer linkerLen =
        if primer.tail.Length <= linkerLen then primer.tail
        else primer.tail.[primer.tail.Length-linkerLen..]

    let fivePrimerTail = getPrimerTail (r'.fivePrimer) len5
    let threePrimerTail = getPrimerTail (r'.threePrimer) len3

    // Insert potentially trimmed tails into rabit ends
    let r =
        {r' with fivePrimer = {r'.fivePrimer with tail = fivePrimerTail; body = r'.fivePrimer.body};
                 threePrimer = {r'.threePrimer with tail = threePrimerTail; body = r'.threePrimer.body}}

    // r.fiveprimer,  r = ryse linker, S = sandwich region, b = body
    //
    // rrrrrrrrrrrrSSSS bbbbbbbbbbb
    // <--tail -------><--body---->
    
    // Require that some reasonable prefix of the tail be a prefix of the appropriate ryse linker
    // or suffix of the reverse complemented ryse linker.  Start by assuming there is no S region,
    // so the whole tail of r.fiveprimer is the suffix
    let rec test (primerTail:char array) (linkerDNA:char array) prefixLen =
        if primerTail.Length = 0 then () // MT linker
        elif prefixLen < 10 then
            failwithf "Insufficient overlap between primer tail %A and RYSE linker %A"
                primerTail linkerDNA
        elif prefixLen > linkerDNA.Length then test primerTail linkerDNA (prefixLen-1)
        else
            let p = primerTail.[..prefixLen-1]
            let s = linkerDNA.[linkerDNA.Length-p.Length..]
            let s' = linkerDNA.[..p.Length-1] |> revComp
            if p = s || p = s' then ()
            else test primerTail linkerDNA (prefixLen-1)

    test r.fivePrimer.tail linker5.dna r.fivePrimer.tail.Length
    test r.threePrimer.tail linker3.dna r.threePrimer.tail.Length

    /// Thumper RYCOD logic that says a linker (primer tail) must be 80% present in design for a rabit
    let checkTailTruncFraction primer linkerLen whichEnd =
        if linkerLen > 0 then
            let tailTruncFraction = (primer.tail.Length |> float) / (float linkerLen)
            if tailTruncFraction < 0.7 then
                failwithf
                    "ERROR: Rabit %s truncated length of %s prime tail (%d) under 70%% of linker length (%d).  Is %f"
                    r.name whichEnd primer.tail.Length linkerLen tailTruncFraction
    
    checkTailTruncFraction r.threePrimer len3 "three"
    checkTailTruncFraction r.fivePrimer len5 "five"

    // Ensure we are chopping off the right thing
    if len5 > 0 then
        assert(r.dnaSeq.[..len5-1] = linker5.dna)
    assert(r.dnaSeq.[r.dnaSeq.Length-len3..] = linker3.dna || r.dnaSeq.[r.dnaSeq.Length-len3..] = revComp linker3.dna )

    arr2seq (r.dnaSeq.[len5..r.dnaSeq.Length-len3-1])

open thumperProxyTypes
/// select best replacement rabit given a list
let chooseBestPart (candidates:RabitCandidate []) =

    /// Which rabit is better
    let betterAThanB (a:RabitCandidate) (b:RabitCandidate) =
        a.id < b.id // for now prefer older rabits


    candidates |> Array.reduce (fun (b:RabitCandidate) v -> if betterAThanB v b then v else b) 

/// Select and implement part reuse in an assembly at the rabit part level 
let reuseThumperParts (linkedTree:AssemblyOut list) =
    let procOnePart (part:DNASlice) =
        match part.rabitCandidates with
            | [||] -> part // no candidates to reuse
            | _ as x -> 
                let bestPart = chooseBestPart x
                // Replace DNA sequence for this part with the expected existing part DNA,
                // and capture the external reference id.  This will result in the message to
                // thumper being by reference rather than by the explicit design we create here.
                // gslc will still design a set of primers etc, but these won't be used.
                { part with dna = bestPart.dna.ToCharArray() ; extId = Some (string bestPart.id)}

    let procOne (assembly:AssemblyOut) =
        { assembly with dnaParts = assembly.dnaParts |> List.map (procOnePart) }

    linkedTree |> List.map (procOne)


/// Truncate and validate rabit primers.
/// Returns a revised Rabit.
let prepRabitForThumper (rabit:Rabit) =
    /// Truncate a primer if it is too long for thumper to handle.
    /// bodyOnly = true trims all extra length from the body of the primer,
    /// otherwise, half is taken from the body and half from the tail.
    let truncatePrimer (primer:Primer) bodyOnly which =
        let body, tail = (primer.body, primer.tail)
        let newBody, newTail =
            if body.Length + tail.Length > maxThumperOligo then
                printfn "Warning: %s truncating %s primer length from %d to %d for thumper"
                    rabit.desc which (body.Length + tail.Length) maxThumperOligo
                if bodyOnly then
                    body.[..maxThumperOligo-1-tail.Length], tail
                else
                    let cutNeeded = body.Length + tail.Length - maxThumperOligo
                    let cutTail = cutNeeded/2

                    let truncTail = tail.[cutTail..]
                    let truncBody = body.[..maxThumperOligo-1-truncTail.Length]
                    truncBody, truncTail
            else
                body, tail
        // SANITY
        assert(newBody.Length + newTail.Length <= maxThumperOligo)
        {primer with body=newBody; tail=newTail}
    
    let ifPrimer = truncatePrimer rabit.IFPrimer false "IF"
    let irPrimer = truncatePrimer rabit.IRPrimer false "IR"

    // Check that internal primers actually match the planned rabit sequence
    let template = (rabit.dnaSeq |> arr2seq)
    let iF = (Array.append ifPrimer.tail ifPrimer.body) |> arr2seq
    if not (template.Contains(iF)) then
        failwithf "Rabit %s iF primer '%s' did not appear in the dna sequence '%s'!"
            rabit.name iF template

    let templateRC = (rabit.dnaSeq |> revComp |> arr2seq)
    let iR = (Array.append irPrimer.tail irPrimer.body) |> arr2seq
    if not (templateRC.Contains(iR)) then
        failwithf "Rabit %s iR primer '%s' did not appear in the dna sequence '%s'!"
            rabit.name iR templateRC

    let fivePrimer = truncatePrimer rabit.fivePrimer true "FWD"
    let threePrimer = truncatePrimer rabit.threePrimer true "REV"

    {rabit with
        IFPrimer = ifPrimer;
        IRPrimer = irPrimer;
        fivePrimer = fivePrimer;
        threePrimer = threePrimer}

/// Convert a Rabit into a SBOL ComponentDefinition.
/// Returns all SBOL top-levels representing the rabit.
let makeSBOLRabit ryseLinkers uri (myR:Rabit) = 

    let fivePrimer, tl5p = sbolPrimer "" (myR.fivePrimer.tail) (myR.fivePrimer.body) Amplification
    let threePrimer, tl3p = sbolPrimer "" (myR.threePrimer.tail) (myR.threePrimer.body) Amplification

    let quickchangePrimers, toplevels = 
        if myR.IFPrimer.body.Length <> 0 then
            let ifPrimer, tlif = (sbolPrimer "" (myR.IFPrimer.tail) (myR.IFPrimer.body) Quickchange)
            let irPrimer, tlir = (sbolPrimer "" (myR.IRPrimer.tail) (myR.IRPrimer.body) Quickchange)
            Some(ifPrimer, irPrimer), tlif@tlir
        else None, []

    let dnaElement =
        sbolDnaElement
            "" // TODO: name
            None
            None
            (trimRyseLinkers ryseLinkers myR)
            (fivePrimer, threePrimer)
            quickchangePrimers

    let rabitOut =
        sbolRabit
            (limitTo thumperRabitNameLength myR.name)
            (sprintf "R%d" myR.id)
            uri
            myR.breed
            myR.direction
            (arr2seq myR.dnaSeq)
            [dnaElement]
            (sbolLinker ryseLinkers.[myR.fiveLink], sbolLinker ryseLinkers.[myR.threeLink])
    
    rabitOut, rabitOut::dnaElement::tl5p@tl3p@toplevels


/// SBOL2/GBoM formatted thumper output
let dumpSbol
        (proj:string)
        (_(*user*):string)
        rabitsOnly
        (megastitches:MegastitchOut list)
        (ryseLinkers:Map<string,RYSELinker>)
        (rabitMap:Map<_,_>)
        (keepRabit:Set<_>)
        (stitchMap:Map<int list, int>)
        (keepStitch:Set<_>) =
    
    let stitchSig (s:StitchOut) = s.rabits |> List.map (fun r -> rabitMap.[r.signature()])

    let mapSID (s:StitchOut) = stitchMap.[stitchSig s]

    // Dump all the rabits, keeping track of their local IDs
    let rabitIds, rabitCDs, allCDs = 
        megastitches
        |> List.map (fun ms -> ms.a.rabits@ms.b.rabits)
        |> List.concat
        |> List.filter (fun r -> keepRabit.Contains(r.id))
        // TODO: once we have SBOL-based part retrieval, we must propagate URIs here.
        |> List.map (fun r -> 
            let cd, topLevels = makeSBOLRabit ryseLinkers None r
            r.id, cd, topLevels)
        |> List.unzip3

    let allRabitCDParts = List.concat allCDs

    let rabitCDById = Map.ofSeq (Seq.zip rabitIds rabitCDs)

    // Dump all the stitches, keeping track of their local IDs
    let stitchIds, stitchCDs =
        seq {for m in megastitches do
                yield m.a
                if m.b.rabits.Length > 0 then yield m.b}
        |> Seq.filter (fun s -> keepStitch.Contains(s.sId))
        |> Seq.map (fun s ->
            let rabitCDs =
                s.rabits |> List.map (fun r ->
                    rabitCDById.[rabitMap.[r.signature()]])
            // TODO: should Stitch URI come from somewhere?  Probably not?
            s.sId, (sbolStitch (sprintf "S%d" s.sId) "" None rabitCDs))
        |> List.ofSeq |> List.unzip

    let stitchCDById = Map.ofSeq (Seq.zip stitchIds stitchCDs)

    let megastitchCDs =
        megastitches
        |> List.map (fun m ->
            // TODO: Megastitch should have an optional URI derived from assembly pragma
            sbolMegastitch
                (sprintf "M%d" m.msId)
                ""
                None
                (stitchCDById.[mapSID m.a])
                (if m.b.rabits.Length = 0 then None else Some(stitchCDById.[mapSID m.b])))

    let gbom =
        if rabitsOnly then compileGbom allRabitCDParts
        else compileGbom (allRabitCDParts@stitchCDs@megastitchCDs)
    let xmlWriterSettings = new XmlWriterSettings()
    xmlWriterSettings.Indent <- true

    use x =
        if proj = "-" then 
            XmlWriter.Create(stdout, xmlWriterSettings)
        else 
            XmlWriter.Create((proj + ".xml"), xmlWriterSettings)
                
    gbom.XElement.WriteTo(x)

/// Convert a Rabit into a RycodRabit
let makeRYCORabit ryseLinkers user (myR:Rabit) = 

    // DNA element spec
    let dna = trimRyseLinkers ryseLinkers myR

    let internalF =
        rycodExample.ThumperRycod.ForwardPrimerSpec(
            myR.IFPrimer.tail |> arr2seq, myR.IFPrimer.body |> arr2seq)
    let internalR =
        rycodExample.ThumperRycod.ReversePrimerSpec(
            myR.IRPrimer.tail |> arr2seq, myR.IRPrimer.body |> arr2seq)

    let qcSpec =
        if internalF.Body.Length = 0 then None
        else Some(new rycodExample.ThumperRycod.QuickChangeSpec(internalF, internalR))

    let des =
        rycodExample.ThumperRycod.DnaElementSpec(
            myR.species,
            rycodExample.ThumperRycod.UpstreamPrimerSpec(
                myR.fivePrimer.tail |> arr2seq, myR.fivePrimer.body |> arr2seq),
            rycodExample.ThumperRycod.DownstreamPrimerSpec(
                myR.threePrimer.tail |> arr2seq, myR.threePrimer.body |> arr2seq),
            (match myR.direction with
             | FWD -> dna
             | REV -> (dna.ToCharArray() |> revComp |> arr2seq)),
            qcSpec)

    rycodExample.ThumperRycod.RabitSpec(
        limitTo thumperRabitNameLength myR.name,
        myR.breed,
        rycodExample.ThumperRycod.UpstreamLinkChoice(myR.fiveLink),
        rycodExample.ThumperRycod.DownstreamLinkChoice(myR.threeLink),
        (match myR.direction with 
         | FWD -> "FWD"
         | REV -> "REV"),
        sprintf "R%d" myR.id,
        user,
        (match myR.extId with | Some(_) -> [||] | None -> [| des |]))

/// RYCO formatted thumper output
let dumpRYCO
        (proj:string)
        (user:string)
        rabitsOnly
        (ms:MegastitchOut list)
        (ryseLinkers:Map<string,RYSELinker>)
        (rabitMap:Map<_,_>)
        (keepRabit:Set<_>)
        (stitchMap:Map<int list, int>)
        (keepStitch:Set<_>) =
    
    let stitchSig (s:StitchOut) = s.rabits |> List.map (fun r -> rabitMap.[r.signature()])

    let mapSID (s:StitchOut) = stitchMap.[stitchSig s]

    // Fill megastitches with refs to stitches
    let megastitchSpecs = 
        [| for myM in ms ->
            let srA = new rycodExample.ThumperRycod.StitchRef(sprintf "S%d" (mapSID myM.a))
            new rycodExample.ThumperRycod.MegastitchSpec(
                sprintf "M%d" myM.msId,
                user,
                (if myM.b.rabits.Length = 0 then
                    [| srA |]
                 else
                    [| srA; new rycodExample.ThumperRycod.StitchRef(sprintf "S%d" (mapSID myM.b)) |])
            )
        |]

    // Fill all the stitches
    let stitchSpecs =
        seq {
            for m in ms do
                yield m.a
                if m.b.rabits.Length > 0 then yield m.b}
        |> Seq.filter (fun s -> keepStitch.Contains(s.sId))
        |> Seq.map (fun myS ->
            rycodExample.ThumperRycod.StitchSpec(
                sprintf "S%d" myS.sId,
                user,
                [| for myR in myS.rabits ->
                        rycodExample.ThumperRycod.RabitRef(
                            sprintf "R%d" (rabitMap.[myR.signature()]))
                |]))
        |> Array.ofSeq

    // Dump all the rabits
    let rabitSpecs = 
        ms
        |> List.map (fun ms -> ms.a.rabits@ms.b.rabits)
        |> List.concat
        |> List.filter (fun r -> keepRabit.Contains(r.id))
        |> List.map (makeRYCORabit ryseLinkers user)
        |> Array.ofList

    let rcr =
        new rycodExample.ThumperRycod.RyseComponentRequest(
            schemaLocation,
            rabitSpecs,
            (if rabitsOnly then [||] else stitchSpecs),
            (if rabitsOnly then [||] else megastitchSpecs))

    use x =
        if proj = "-" then 
            new XmlTextWriter(stdout)
        else 
            new XmlTextWriter(new StreamWriter(proj + ".xml"))
                
    x.Formatting <- Formatting.Indented
    rcr.XElement.WriteTo(x)





/// Thumper inputs - rabits, stitches, 
let dumpThumper
        (opts:ParsedOptions)
        (genomePrefixes:Map<string,string>) 
        (markerSets:Set<HalfMarker>) 
        (ryseLinkers:Map<string,RYSELinker>) 
        (hutchAncillary:Map<int,HutchRabit>) 
        proj 
        (assemblies:AssemblyOut list) 
        (primers:DivergedPrimerPair list list)
        sbolOutput =
    // Note linkers were assigned earlier in mapRyseLinkers

    // User has option of requesting no primers but in turn we can't generate
    // sane linkers without primers so we pass the buck
    //let linkerless = opts.noPrimers

    /// Thread a counter through the rabit pile and assign ids
    let assignIds (ms:MegastitchIn list) =
        /// Assign ids for one stitch
        let assignStitch nextId (rl:Rabit list) =
            rl |> List.mapi (fun i (r:Rabit) -> {r with id = nextId + i}), nextId + rl.Length

        /// Assign ids for one megastitch
        let rec assignMS nextId (ms:MegastitchIn list) res =
            let msId = nextId
            match ms with
            | [] -> List.rev res
            | msIn::tl -> 
                let s1Id = nextId + 1
                let s2Id = nextId + 2
                let a', ni = assignStitch (nextId+3) msIn.rabit1
                let b', ni' = assignStitch ni msIn.rabit2
                assignMS
                    ni'
                    tl
                    ({msId = msId; // Create a megastitch and assign id
                      a = {sId = s1Id; rabits = a'};   // Sub stitches
                      b = {sId = s2Id; rabits = b'};
                      name = msIn.name;}
                     ::res)
        
        assignMS 1000 ms []

    /// Take a joint zip of primers and DNAParts and split into two stitches,
    /// keeping marker in both parts
    let rec splitOnMarker
            (errorDesc:string)
            markerSet 
            isSingle 
            r1 
            r2 
            step 
            (lastLinker:string) 
            (pp:(DivergedPrimerPair*DNASlice) list) = 

        let markerSet' = if markerSet = "default" then "ura3lo" else markerSet

        let uraFirst =
            markerSets
            |> Seq.choose (fun ms ->
                if ms.name = markerSet' && ms.part1or2 = 1
                then Some(ms.linkerFr,ms.rid)
                else None)
            |> Map.ofSeq

        let uraSecond =
            markerSets
            |> Seq.choose (fun ms ->
                if ms.name = markerSet' && ms.part1or2 = 2
                then Some(ms.linkerFr,ms.rid)
                else None)
            |> Map.ofSeq
    
        let nine = "CGGTGTTTAAACCCCAGCGCCTGGCGGG".ToCharArray()

        // Build up the linker entry 
        let nineLinker =
            {id = None;
             extId = None; 
             sliceName = "";
             uri = Some(linkerUri "9");
             dna = nine; 
             sourceChr = "linker";
             sourceFr = 0<ZeroOffset>;
             sourceTo = 0<ZeroOffset>; 
             sourceFrApprox = false;
             sourceToApprox = false;
             template = None;
             amplified = false;
             destFr = -999<ZeroOffset>;
             destTo = -999<ZeroOffset>;
             sourceFwd = true;
             description = "Linker_9"; 
             sliceType = LINKER;
             destFwd = true;
             dnaSource = "";
             pragmas = EmptyPragmas;
             breed = B_LINKER;
             rabitCandidates = Array.empty;}//flag_LiangMi

        let ninePrimer =
            DPP({fwd =
                    {tail = nine;
                     body = [||]; 
                     annotation = [{il=0;ir=nine.Length-1; iType = DNAIntervalType.RYSELINKER}]};
                 rev =
                    {body = [||];
                     tail = revComp nine;
                     annotation = [{il=0;ir=nine.Length-1; iType = DNAIntervalType.RYSELINKER}]};
                 name = errorDesc })

        /// Dump out rabit list in human friendly form for diagnostics
        let diagnostic (r:(DivergedPrimerPair*DNASlice) list) =
            seq {for _, slice in (List.rev r) -> slice.description}
            |> fun x -> String.Join(" ; ",x)

        match pp with
        | [] ->
            if isSingle then (List.rev r1),[] 
            else 
                match step with
                | 1 ->  
                    failwithf "ERROR: expected ### marker part in %s\n" errorDesc
                | 2 -> r1, (List.rev r2)
                | _ -> failwithf "inconceivable case in splitOnMarker"

        | (hp,hd)::(hp2,hd2)::tl when hd.sliceType = MARKER -> 
            assert(step = 1)
            // This is pretty evil.  Since the stitches have different numbers of
            // parts, you might need a 3 .. 9 or 2.. 9 or X .. 9 marker half, so
            // we need to worry about what the last linker was.  We also need the
            // next linker to work out how to start off the second stitch, so the
            // hp2, hd2 is peeking ahead to see what happens next
            let nextLinker = extractLinker hd2.description
            if isSingle then
                failwithf
                    "ERROR: no support for ### style markers in stitch only constructs, \nfound part %s  in design \n %s \n"
                    hd.description errorDesc 
                // To support this, we would need sequences for the full marker.  Need to build out
                // proper marker sets rather than hard coding sets of half URA markers.
            if not (uraFirst.ContainsKey(lastLinker)) then
                failwithf "ERROR:  can't find suitable %s-9 %s 1/2 part diag=(%A)\n description: %s"
                    lastLinker markerSet (diagnostic r1) errorDesc
            if not (uraSecond.ContainsKey(nextLinker)) then
                failwithf "ERROR:  can't find suitable %s-9 %s 2/2 part (%A) %s"
                    nextLinker markerSet (diagnostic r2) errorDesc

            let extId1, extId2 = uraFirst.[lastLinker], uraSecond.[nextLinker]
            splitOnMarker
                errorDesc 
                markerSet 
                isSingle 
                ((ninePrimer,nineLinker)::(hp,{hd with extId = Some(sprintf "%d" extId1)})::r1 |> List.rev)
                [(hp,{ hd with extId = Some(sprintf "%d" extId2)}); (ninePrimer,nineLinker)] 
                2 
                lastLinker
                ((hp2,hd2)::tl) // Push hp2, hd2 back onto the worklist

        | (hp,hd)::tl when step = 1 -> 
            let lastLinker' =
                if hd.sliceType = LINKER then extractLinker hd.description
                else lastLinker
            splitOnMarker errorDesc markerSet isSingle ((hp,hd)::r1) r2 1 lastLinker' tl

        | (hp,hd)::tl when step = 2 -> 
//            let lastLinker' =
//                if hd.sliceType = LINKER then extractLinker hd.description
//                else lastLinker
            splitOnMarker errorDesc markerSet isSingle r1 ((hp,hd)::r2) 2 lastLinker tl

        | _ -> failwithf "ERROR: unexpected state in splitOnMarker %d %A %s" step pp errorDesc
    
    /// Take a list of primer pair/dna slice tuples and restructure
    /// the sub rabit pieces into a rabit.  Make sure this rabit's features
    /// are thumper-compatible (mostly truncating long primers)
    let packageRabit (pl:(DivergedPrimerPair*DNASlice) list) =
        let primers, parts = List.unzip pl
        
        // First deal with primers.  In general Can be 2 or 3.
        //3 means a 2 piece rabit with internal primers
        let activePrimers =
            primers |> List.choose (fun dpp ->
                match dpp with
                | GAP -> None
                | DPP(x) -> Some(x))

        let TF,IR,IF,TR = 
            match activePrimers with
            | [ a; b; c ] -> a.fwd, b.rev, b.fwd, c.rev
            | [ a; c ] ->
                (a.fwd,
                 {tail=[||]; body=[||]; annotation = []},
                 {tail=[||]; body=[||]; annotation = []},
                 c.rev)
            | _ ->
                let parts =
                    pl |> List.map (fun (_,b) -> b.description)
                    |> fun x -> String.Join(";",x)
                failwithf
                    "ERROR: bad primer configuration in packageRabit, expect 2 or 3 primers, have %d\n parts=%s %A\n"
                    activePrimers.Length parts activePrimers
        
        let fullName =
            parts |> List.choose (fun ds ->
                match ds.sliceType with
                | LINKER -> None
                | _ -> Some(ds.description))
            |> Array.ofList |> fun s -> String.Join(";",s)
        
        /// Shouldn't label something as having an external ID if it has been modified in anyway otherwise thumper output
        /// will just to use the part by reference
        let extId = 
            match (parts |> List.filter (fun p -> p.sliceType <> LINKER)) with
            | [a] when a.extId.IsSome -> a.extId  // If rabit is a single piece DNA with a concrete external ID
            | _ -> None

        let hutchRef =
            match extId with 
            | None -> None
            | Some(i) ->
                let ri = int i
                if hutchAncillary.ContainsKey(ri) then Some(hutchAncillary.[ri])
                else getHutchInfoViaWeb ri
                                    
        // Extract a name for the rabit if there's any hint from the sub pieces
        let namePre =
            match hutchRef with
            | Some(hr) -> hr.name
            | None ->
                match parts |> List.tryFind (fun slice -> slice.sliceName <> "" && slice.sliceType <> FUSIONST)
                    with
                | Some(partWithName) -> partWithName.sliceName
                | None -> fullName.Substring(0,min maxNameLen fullName.Length)

        // See if any DNA parts have their dna source labeled?
        let dnaSources =
            match
                parts |> List.choose (fun slice ->
                    if slice.dnaSource <> "" then Some(slice.dnaSource) else None)
                |> Seq.distinct |> List.ofSeq
                with
            | [] -> ["CENPK2"] // default if nobody speaks up
            | [_] as x -> x
            | x -> 
                printf "WARNING: multiple dna sources in one rabit not well supported %A\n" x
                x 
        let dnaSource = String.Join("+", dnaSources)
        // temporary hack to deal with mixed species constuct.  FIXFIX TODO
        let name =
            match genomePrefixes.TryFind(dnaSource) with
            | None -> namePre // "Hpoly" -> "Hp." + namePre
            | Some(x) -> 
                // There is a name for the current DNA source, but if this part is a rabit or marker,
                // we still don't want to slap on the prefix
                if (parts |> List.exists (fun p -> p.sliceType = MARKER || p.extId.IsSome))
                then namePre
                else sprintf "%s.%s" x namePre

        // TODO - estimate breed 
        let breed =
            match parts |> List.tryFind (fun part -> part.sliceType = MARKER) with
            | Some(_) -> "M"
            | None ->
                match hutchRef with
                | None -> estBreed parts
                | Some(hr) -> hr.breed // pull noted breed

        // work out linker name
        let fiveLink = List.head parts
        let threeLink = Seq.last parts
        let dna = parts |> List.map (fun ds -> ds.dna) |> Array.concat

        // Warning - if all parts are reversed in a rabit, call it reverse locus orientation but
        // otherwise (mixed or all fwd) it is fwd.
        //printf "DEBUGGING: orientation:   "
        //for p in parts do
        //    printf "%s %s , " p.description (if p.destFwd then "fwd" else "rev")
        //printf "\n"

        let direction =
            if parts |> List.filter (fun p -> p.sliceType <> LINKER && p.sliceType <> FUSIONST)
               |> List.forall (fun p -> not p.destFwd)
            then REV
            else FWD 
        // Note direction defaults to '0', assuming everything in the construct is fwd for now
        let rabit = 
            {id = -1; 
             extId = extId; 
             breed = breed; 
             direction = direction; 
             fiveLink = (extractLinker fiveLink.description); 
             threeLink = (extractLinker threeLink.description); 
             name = name; 
             species = dnaSource;
             seqName = name; 
             desc = fullName; 
             fivePrimer = TF; 
             threePrimer = TR; 
             IFPrimer = IF; 
             IRPrimer = IR;
             dnaSeq = dna;
             aaSeq = ""; 
             notes = "";
             dnaSources = dnaSources}
        prepRabitForThumper rabit

    /// Take a list of primerpairs, DNA slices and decide where the rabit boundaries
    /// are by looking at which primers are linkers.  Makes sub lists of sections that
    /// belong in one rabit.
    let splitOnRabits pp =
        let rec _splitOnRabits pp current res =
            match pp with
            | [] -> List.rev res // Done, invert reverse accumulated order
            | (primer, ds)::tl when ds.sliceType = LINKER ->
                // When we hit a linker, push the current part collection to the results (res) list
                // unless we are starting and it's empty
                if current = [] then 
                    _splitOnRabits tl [(primer,ds)] [] 
                else 
                    _splitOnRabits tl [(primer,ds)] (((primer,ds)::current |> List.rev)::res) 
            | hd::tl ->
                // Push onto current rabit parts list
                _splitOnRabits tl (hd::current) res
        _splitOnRabits pp [] []

    /// Do some checks on orientation of the rabits.  For rabits we are reusing, make sure the direction
    /// we want for construction is consistent with that of the part in the hutch.  If not, give a warning
    /// but correct it to the hutch version so we can still build.    
    let rabitDirEnforcement rabits =

        rabits |> Seq.map (fun r ->
            match r.extId with
            | None -> r
            | Some(eId) ->
                let ri = int eId
                match hutchAncillary.TryFind(ri) with
                | Some(hr) ->
                    if hr.orient <> r.direction then
                        printf
                            "WARNING: rabit R%s has design orientation %c and hutch orientation %c, correcting to hutch orient\n"
                            eId (r.direction.toChar()) (hr.orient.toChar())
                        {r with direction = hr.orient}
                    else r
                // Let rabit through, not much we can do if we can't find it
                | None -> r)

    /// Apply checks to rabit
    let checkRabit (r:Rabit) =
        let dna = r.dnaSeq |> arr2seq
        let dnaRC = r.dnaSeq |> revComp |> arr2seq

        let find (a:char array) = 
            let a' = arr2seq a
            match dna.Contains(a'), dnaRC.Contains(a') with
            | true, true -> "both"
            | true, false -> "f"
            | _ -> "r" // FIXME: we do not handle the case where we don't find either!
        if r.IFPrimer.Primer.Length > 0 then
            // Has internal quick change primer, ensure they point in the same direction
            // as the rabit itself.
            let checkPrimer (qcPrimer:Primer) (rabitPrimer:Primer) which = 
                let qcOrient = find qcPrimer.body
                let rOrient = find rabitPrimer.body
                if qcOrient <> "both" && rOrient <> "both" && qcOrient <> rOrient then
                    failwithf " ERROR: internal check for %s orientation fails %s/%s  %s/%s\n"
                        which rOrient qcOrient (arr2seq rabitPrimer.body ) (arr2seq qcPrimer.body)
            checkPrimer r.IFPrimer r.fivePrimer "F/IF"
            checkPrimer r.IRPrimer r.threePrimer "R/IR"

    

    /// Main "top level" code for dumpThumper, using routines above
    let main() =            
        let legalMarkers = markerSets |> Set.map (fun halfMarker -> halfMarker.name) |> Set.add("default")

        /// Find out if anyone specified a user anywhere in the assembly collection
        let user =
            match assemblies |> List.tryPick (fun a -> a.pragmas.TryGetOne("user")) with
            | None -> defaultUser
            | Some(u) -> u
        
        /// Assemble a megastich from a primer list and an assembly.
        let makeMS (primerList, assem:AssemblyOut) =
            // Find marker

            // Might be a single stitch, in which case we need to handle
            // the "marker split" differently as it won't happen
            let monoMega = assem.pragmas.ContainsKey("stitch")
            let markerSet =
                match assem.pragmas.TryGetOne("markerset") with
                | Some(x) ->
                    let x' = x.ToLower()
                    if not (legalMarkers.Contains(x')) then
                        failwithf "ERROR: unknown marker set %s, expected one of %s\n"
                            x' (String.Join(",",legalMarkers))
                    else x'
                | None -> "default"

            // In case we have to give the user bad news, make a recognizable error message
            let errorDesc = assem.dnaParts |> Seq.map (fun p -> p.description) |> fun x -> String.Join(";",x)
            let p1,p2 = splitOnMarker errorDesc markerSet monoMega [] [] 1 "?" (List.zip primerList assem.dnaParts)
        
            // Need to gather up everything between pairs of linkers
            let rabits1 = splitOnRabits p1 |> List.map (packageRabit) |> rabitDirEnforcement |> List.ofSeq
            // Publish B stitch in from the outside to the center
            let rabits2 =
                splitOnRabits p2 |> List.map (packageRabit) |> List.map (fun r -> r.flip())
                |> List.rev |> rabitDirEnforcement |> List.ofSeq
            
            // This is effectively the megastitch
            {rabit1 = rabits1; rabit2 = rabits2; name = assem.name}

        // Assign IDs to everything in the structure 
        // with ids poked in
        
        let megastitches =
            (Seq.zip primers assemblies)
            |> (Seq.map makeMS)
            |> List.ofSeq
            |> assignIds

        // Export the mapping from megastitch id# etc to user name for megastitches
        if opts.name2IdPath.IsSome || proj <> "-" then
            let path = match opts.name2IdPath with
                        | None -> sprintf "%s.name2id.txt" proj
                        | Some(p) -> p

            use nameMappingF = new StreamWriter(path)
            nameMappingF.WriteLine ("id\tusername")
            for ms in megastitches do
                nameMappingF.WriteLine(sprintf "M%d\t%s" ms.msId ms.name)

        // Do a straight dump of the rabits
        let rabits = megastitches |> List.map (fun ms -> ms.a.rabits@ms.b.rabits) |> List.concat

        // Apply any sanity checks to the rabits
        for r in rabits do checkRabit r

        let header = "id\tType/Breed\tDirection\t5' link\t3' link\tInsert Name\tSpecies\tSequence Name\tDescription\t5' primer\t3' primer\tIF Primer\tIR Primer\tDNA Sequence\tAA Sequence\tNotes\tRabitLen\tPCR1len\tPCR2len"
        
        (*
        // Unimplemented template output format
        if proj <> "-" then
            use sourceF = new StreamWriter(sprintf "%s.templates.txt" proj)
            sourceF.WriteLine("id\tslot\tsource")
            for r in rabits do
                for source in r.dnaSources do
                    sourceF.WriteLine(sprintf "R%d\t")
        *)
              
        if proj <> "-" then
            use rabitF = new StreamWriter(sprintf "%s.rabits.txt" proj)
    
            rabitF.WriteLine(header)
            for r in rabits do
                let dna = trimRyseLinkers ryseLinkers r
                let rabitLen = dna.Length
                let p1Len,p2Len =
                    if r.IFPrimer.Primer.Length = 0 then "",""
                    else
                        let dnaStr = arr2seq r.dnaSeq
                        let p1 = dnaStr.IndexOf(r.IRPrimer.body |> revComp |> arr2seq) + r.IFPrimer.Primer.Length
                        let p2 = dnaStr.Length - dnaStr.IndexOf(r.IFPrimer.body |> arr2seq) + r.IFPrimer.tail.Length
                        sprintf "%d" p1,sprintf "%d" p2

                let s = sprintf "%s\t%s\t%c\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%d\t%s\t%s"
                            (match r.extId with | None -> sprintf "r%d" r.id | Some(extId) -> extId)
                            r.breed (r.direction.toChar()) r.fiveLink r.threeLink r.name r.species 
                            r.seqName r.desc (arr2seq r.fivePrimer.Primer) (arr2seq r.threePrimer.Primer)
                             (arr2seq r.IFPrimer.Primer)
                              (arr2seq r.IRPrimer.Primer) dna r.aaSeq r.notes
                              rabitLen p1Len p2Len
                rabitF.WriteLine(s)
            use stitchF = new StreamWriter(sprintf "%s.stitches.txt" proj)
            let headerS = "Stitch ID\tSlot 1\tSlot 2\tSlot 3\tSlot 4\tSlot 5\tSlot 6\tSlot 7\tSlot 8\tSlot 9\tTags"
            stitchF.WriteLine(headerS)

            let stitches = seq {for m in megastitches do
                                    yield m.a
                                    // Only yield b stitch if we actually generated it
                                    if m.b.rabits.Length > 0 then
                                        yield m.b }
            for s in stitches do
                let col1 = sprintf "%d" s.sId
                let ids = List.map (fun s -> match s.extId with | Some(i) -> i | None -> sprintf "r%d"  s.id) s.rabits
                let gaps = seq { for _ in {0..10-s.rabits.Length} -> ""} |> List.ofSeq
                stitchF.WriteLine(String.Join("\t",col1::ids@gaps))

            use megaF = new StreamWriter(sprintf "%s.mega.txt" proj)
            let headerM = "Mega Stitch ID\tStitch A ID\tStitch B ID"
            megaF.WriteLine(headerM)
            for m in megastitches do
                megaF.WriteLine(sprintf "%d\t%d\t%d" m.msId m.a.sId m.b.sId)

        // remove duplicate rabits by mapping them onto a canonical id
        let rabitMap =
            seq {for r in rabits -> r.signature(), r.id}
            |> Seq.rev // this is not necessary but preserves (unimportant) legacy id ordering
            |> Map.ofSeq

        // set of active rabit ids
        let keepRabit = rabitMap |> Seq.map (fun pk -> pk.Value) |> Set.ofSeq

        let stitchSig (s:StitchOut) = s.rabits |> List.map (fun r -> rabitMap.[r.signature()])
        // remove duplicate stitches by mapping them onto a canonical id
        let stitchMap =
            seq {
                for m in megastitches do
                    yield m.a
                    // Only if B stitch really has anything in it
                    if m.b.rabits.Length > 0 then yield m.b}
            |> Seq.rev // this is not necessary but preserves (unimportant) legacy id ordering
            |> Seq.map (fun s -> stitchSig s, s.sId)
            |> Map.ofSeq

        let keepStitch = stitchMap |> Seq.map (fun pk -> pk.Value) |> Set.ofSeq
      
        // Always do XML even if proj is - (stdout)
        if sbolOutput then
            dumpSbol
                proj 
                user 
                opts.rabitsOnly 
                megastitches 
                ryseLinkers 
                rabitMap 
                keepRabit 
                stitchMap 
                keepStitch
        else
            dumpRYCO
                proj 
                user 
                opts.rabitsOnly 
                megastitches 
                ryseLinkers 
                rabitMap 
                keepRabit 
                stitchMap 
                keepStitch

    // This is the top level part of the whole dumpThumper function
    // using the various functions defined within it
    main()


module pragmaTypes
open System
    
type PragmaArgShape = 
    | Zero
    | One
    | Exactly of int
    | AtLeast of int
    // Range is inclusive on both sides, so Range(1,5) accepts one to five parameters.
    | Range of int * int
    // For the uncommon case where a pragma might accept on a set of exact
    // numbers of arguments, possibly to dictate behavior.
    | ExactlySet of int list

type PragmaValidationResult =
    | Ok
    | Error of string list

/// Pragmas are scoped within a GSL document.  Some pragmas
/// are somewhat "scope-polymorphic" and have different
/// behavior depending on which scope they appear in.
/// Specifying scope for pragmas also allows better error collection
/// during parsing.
type PragmaScope =
    | Part // inline pragmas that operate on single parts
    | Assembly // pragmas that operate on the assembly in which they appear
    | Global // pragmas that operate on all subsequent asseblies
    with
    member x.ToString =
        match x with
        | Part -> "Part"
        | Assembly -> "Assembly"
        | Global -> "Global"

/// Some pragmas need to be handled in special ways.
/// Those ways are enumerated here.
type PragmaProperty =
    | Transient
    // If this pragma is inversion-sensitive, it should invert to this named pragma.
    | InvertsTo of string

/// Formal declaration of a pragma.
/// A pragma is fully specified by its name and the shape of the arguments it accepts.
/// A validation function may be optionally provided to fail fast during parsing
/// rather than when the pragma is used.
type PragmaDef = {
    name: string;
    argShape: PragmaArgShape;
    desc: string;
    scope: PragmaScope list;
    properties: PragmaProperty list;
    validate: (string list -> PragmaValidationResult);}

/// Instance of a pragma directive.
[<CustomEquality; CustomComparison>]
type Pragma = {
    definition: PragmaDef;
    args: string list}
    with
    member x.name = x.definition.name
    member x.isTransient = x.definition.properties |> List.contains Transient
    /// Helper function to check the list of args for a particular value.
    member x.hasVal(value:string) = 
        List.contains value x.args
    /// Only consider pragma name and args in comparions.
    override x.Equals(obj) =
        match obj with
        | :? Pragma as p -> (x.name = p.name && x.args = p.args)
        | _ -> false
    /// Hash a Pragma as a combination of pName and args.
    override x.GetHashCode() = hash (x.name, x.args)
    interface System.IComparable with
        member x.CompareTo obj =
            match obj with
            | :? Pragma as p -> compare (x.name, x.args) (p.name, p.args)
            | _ -> invalidArg "obj" "cannot compare values of different types"

// GSLc built-in pragma defintions
// These are specified in a TSV file and code-generated by a python script in
// gslc/scripts/
// TODO: refactor out Amyris-internal pragmas into an external module and load them.

// Helper functions for generic validation of simple parameters.
let parseNumber parseFunc kind (args:string list) =
    match args with
    | [i] ->
        match parseFunc i with
        | true, _ -> Ok
        | false, _ -> Error([sprintf "Could not parse %s as an %s." i kind])
    // We shouldn't ever hit this clause as we should have already blown up with
    // a different error.
    | x -> Error([sprintf "parse number expected one argument but got %d" x.Length])

let parseInt = parseNumber (Int64.TryParse) "int"
let parseDouble = parseNumber (Double.TryParse) "float"

/// Pass-through placeholder validator.
let noValidate _ = Ok
/// Base set of hard coded pragmas.  Plugins might augment this list
let pragmaDefsStatic : PragmaDef list =
   [{name = "push"; argShape = Zero; scope = [Part];
     desc = "Push transient pragmas onto stack.";
     properties = []; validate = noValidate}
    {name = "pop"; argShape = Zero; scope = [Part];
     desc = "Pop transient pragma stack.";
     properties = []; validate = noValidate}
    {name = "warn"; argShape = AtLeast(1); scope = [Part; Assembly; Global];
     desc = "Print a warning message.";
     properties = [Transient]; validate = noValidate}
    {name = "linkers"; argShape = AtLeast(1); scope = [Global];
     desc = "Override the default set of RYSE linkers.";
     properties = []; validate = noValidate} // TODO: import linker parse function here
    {name = "refgenome"; argShape = One; scope = [Part];
     desc = "Specify a reference genome.";
     properties = []; validate = noValidate}
    {name = "dnasrc"; argShape = One; scope = [Part];
     desc = "Specify a DNA source for a part.";
     properties = []; validate = noValidate}
    {name = "name"; argShape = One; scope = [Part; Assembly];
     desc = "Override name for a assembly or part.";
     properties = [Transient]; validate = noValidate}
    {name = "fuse"; argShape = Zero; scope = [Part];
     desc = "Create a seamless junction with the next part.";
     properties = []; validate = noValidate}
    {name = "stitch"; argShape = Zero; scope = [Assembly];
     desc = "TODO description";
     properties = []; validate = noValidate}
    {name = "megastitch"; argShape = Zero; scope = [Assembly];
     desc = "TODO description";
     properties = []; validate = noValidate}
    {name = "markerset"; argShape = One; scope = [Global];
     desc = "Set the default marker set for a ### part.";
     properties = []; validate = noValidate}
    {name = "rabitstart"; argShape = Zero; scope = [Part];
     desc = "Designate part as the start of a RYSE rabit.";
     properties = [InvertsTo("rabitend")]; validate = noValidate}
    {name = "rabitend"; argShape = Zero; scope = [Part];
     desc = "Designate part as the end of a RYSE rabit.";
     properties = [InvertsTo("rabitstart")]; validate = noValidate}
    {name = "primerpos"; argShape = Exactly(2); scope = [Part];
     desc = "Dictate forward FWD or reverse REV primer position relative to first base of a short inline slice";
     properties = []; validate = noValidate} // TODO parse function here
    {name = "warnoff"; argShape = One; scope = [Assembly];
     desc = "Turn off specific warnings.";
     properties = []; validate = noValidate} // TODO parse function here
    {name = "primermax"; argShape = One; scope = [Global];
     desc = "Max length of primer that can be designed.";
     properties = []; validate = parseInt}
    {name = "primermin"; argShape = One; scope = [Global];
     desc = "Max length of primer that can be designed.";
     properties = []; validate = parseInt}
    {name = "pcrparams"; argShape = Range(1,5); scope = [Global];
     desc = "Set various parts of PCR conditions.";
     properties = []; validate = noValidate} // TODO PCR conditions parse function
    {name = "targettm"; argShape = One; scope = [Global];
     desc = "Set target melting temperature for pcr designs.";
     properties = []; validate = parseDouble}
    {name = "seamlesstm"; argShape = One; scope = [Global];
     desc = "Set target melting temperature for seamless designs (body of primer that amplifies the two pieces adjacent to the junction).";
     properties = []; validate = parseDouble}
    {name = "seamlessoverlaptm"; argShape = One; scope = [Global];
     desc = "Set target melting temperature for the tail of the seamless primers that overlap in the middle to form the junction.";
     properties = []; validate = parseDouble}
    {name = "atpenalty"; argShape = One; scope = [Global];
     desc = "Set degree of tm flexibility to get a terminal G or C and unstable 3' end of an oligo.";
     properties = []; validate = parseDouble}
    {name = "pcrassemblyparams"; argShape = Range(1,5); scope = [Global];
     desc = "Set melting conditions for the overlap junction in a seamless design.";
     properties = []; validate = noValidate} // TODO PCR conditions parse function
    {name = "minoverlaplen"; argShape = One; scope = [Global];
     desc = "Sets the minimum overlap length for junction in a seamless design.";
     properties = []; validate = parseInt}
    {name = "capa"; argShape = One; scope = [Global];
     desc = "Enables particular compiler capabilities.";
     properties = []; validate = noValidate}
    {name = "len"; argShape = One; scope = [Part];
     desc = "Set specific heterology block length for a ~ part.";
     properties = []; validate = parseInt}
    {name = "user"; argShape = One; scope = [Global];
     desc = "Set owner for any output fields with a creator field";
     properties = []; validate = noValidate}
    {name = "style"; argShape = One; scope = [Part];
     desc = "Set allele swap style.";
     properties = []; validate = noValidate}
    {name = "breed"; argShape = One; scope = [Part];
     desc = "Specify RYSE breed for a specific rabit, overriding any breed inference.";
     properties = []; validate = noValidate}
    {name = "inline"; argShape = Zero; scope = [Part];
     desc = "Force long inline sequences to be created inline as part of a 2 piece rabit regardless of length.";
     properties = []; validate = noValidate}
    {name = "seed"; argShape = One; scope = [Global; Part];
     desc = "Sets the seed for the random number generator for things like codon optimization.";
     properties = []; validate = parseInt}
    {name = "codonopt"; argShape = AtLeast 1; scope = [Global];
     desc = "Set codon optimization parameters.";
     properties = []; validate = noValidate}
    {name = "uri"; argShape = One; scope = [Part; Assembly];
     desc = "Tag a part or assembly with a URI.";
     properties = []; validate = noValidate}
    {name = "line"; argShape = One; scope = [Assembly];
     desc = "Persistent GSL file line numbering.  Unimplemented.";
     properties = []; validate = parseInt};
     {name = "swapend"; argShape = One; scope = [Part];
     desc = "State an end preference for an allele swap. Arg should be '3' or '5'.";
     properties = []; validate = parseInt}
    ]

/// Legal/Valid pragma names and defintions for lookup by name
let mutable legalPragmas : Map<_,_> option = None
let mutable pragmaDefs : PragmaDef list option = None

let rec finalizePragmas pluginPragmas =
    pragmaDefs <- Some (pluginPragmas@pragmaDefsStatic)
    legalPragmas <- Some ( pragmaDefs.Value
                            |> List.map (fun p -> p.name, p) 
                            |> Map.ofList
                         )  
    /// Idiot check that we don't have any duplicate pragmas.
    if legalPragmas.Value.Count <> pragmaDefs.Value.Length then
        failwithf "%d pragmas were defined but size of legalPragmas map is only %d. Name aliases?"
            (pragmaDefs.Value.Length) (legalPragmas.Value.Count)


    /// Make sure any pragmas that invert do it sensibly.
    pragmaDefs.Value  |> List.choose pragmaInverts |> ignore
and pragmaInverts p =
// FIXME: this function mixes validation and retrieval and is called by client code.
// Refactor to separate these things.
/// Determine if a pragma inverts, and validate that it inverts to a compatible pragma.
/// Returns the definition of the pragma it inverts to.

    let invertsTo =
        p.properties
        |> List.choose (fun prop -> match prop with | InvertsTo(x) -> Some(x) | _ -> None)
    match invertsTo with
    | [] -> None
    | [x] ->
        match legalPragmas with
        | None -> failwithf "ERROR: internal, pragmaInverts legalPragmas uninitialized"
        | Some lp ->
            match lp.TryFind x with
            | None ->
                failwithf "Pragma %s inverts to an unknown pragma %s" (p.name) x
            | Some(invTo) -> // inverts to a known pragma, make sure they have the same shape
                if p.argShape <> invTo.argShape then
                    failwithf "Pragma %s inverts to %s but they have differing argShapes."
                        (p.name) (invTo.name)
                Some(invTo)
    | _ -> failwithf "Pragma %s inverts to more than one pragma." (p.name)
    // TODO: the presence of this last clause tells us that an extensible list of
    // pragma properties might not be the best type for this domain, but it isn't
    // the end of the world.  Prefer this to infectious fields on every pragma.

/// Format a pragma definition.
let formatPragma p =
    let argDescFormat v = sprintf "<a%d>" v
    let makeArgDesc (n:int) = [0..n-1] |> Seq.map argDescFormat |> String.concat " "
    let argDesc = 
        match p.argShape with
        | Zero -> ""
        | One -> makeArgDesc 1
        | Exactly(n) -> makeArgDesc n
        | AtLeast(n) -> (makeArgDesc n) + " ..."
        | Range(n, m) -> (makeArgDesc n) + " (..." + (argDescFormat (m-1)) + ")"
        | ExactlySet(v) -> sprintf " <arg shapes: %A>" v
    let scopeDesc = p.scope |> List.map (fun s -> s.ToString) |> String.concat ", "
    let firstLine = sprintf "#%s %s" p.name argDesc
    let descLines = p.desc.Split [|'\n'|] |> List.ofArray |> List.map (fun d -> "    " + d)
    let scopeLine = sprintf "    Scoping: %s" scopeDesc
    (firstLine::scopeLine::descLines) |> String.concat "\n"

/// Print all available pragmas.
let pragmaUsage () =
    let orderedPragmas = 
        match pragmaDefs with
            | None -> failwithf "ERROR: internal error, pragma def initialization not finalized"
            | Some p -> p|> List.sortBy (fun p -> p.name)
    for p in orderedPragmas do printfn "%s" (formatPragma p)

/// This pragma is constructed manually during expansion.
let namePragmaDef() =
    match legalPragmas with
        | None -> failwithf "ERROR: internal, legalPragmas uninitialized"
        | Some lp ->
            match lp.TryFind "name" with
            | Some(p) -> p
            | None -> failwith "The #name pragma must be defined, but is not in legal pragmas."

/// Raise an exception if pName is not among the registered pragmas.
let validatePragmaName pName =
    match legalPragmas with
        | None -> failwithf "ERROR: internal, legalPragmas uninitialized"
        | Some lp ->
            if not (lp.ContainsKey pName) then
                failwithf "Requested unknown pragma '#%s'."
                    pName

/// Validated pragma construction during parsing
/// Fails with an exception if the pragma doesn't exist or has the wrong number of args.
let buildPragma (name:string) (values:string list) =
    // try to get the pragma defintion
    let def =
        match legalPragmas with
            | None -> failwithf "ERROR: legalPragmas uninitialized in buildPragma"
            | Some lp ->
                match lp.TryFind name with
                | Some(p) -> p
                | None -> failwithf "Unknown or invalid pragma: '#%s'" name

    // check that the right number of arguments were supplied
    let nArg = values.Length
    let checkNArgs n =
        if nArg <> n then
            failwithf "Pragma #%s expected %d argument(s) but got %d: %A"
                name n nArg values
    let checkMinArgs min =
        if nArg < min then
            failwithf "Pragma #%s expected at least %d argument(s) but got %d: %A"
                name min nArg values
    let checkMaxArgs max =
        if nArg > max then
            failwithf "Pragma #%s expected at most %d argument(s) but got %d: %A"
                name max nArg values
    match def.argShape with
    | Zero -> checkNArgs 0
    | One -> checkNArgs 1
    | Exactly(n) -> checkNArgs n
    | AtLeast(n) -> checkMinArgs n
    | Range(min,max) ->
        checkMinArgs min
        checkMaxArgs max
    | ExactlySet(vals) ->
        if not (vals |> List.contains nArg) then
            failwithf "Pragma %s expected any number of arguments in the set %A but got %d: %A"
                name vals nArg values

    // Run validation on the arguments
    match def.validate values with
    | Error(errs) ->
        failwithf "Errors occurred when validating arguments to #%s: %A" name errs
    | Ok -> {definition = def; args = values}

/// A PragmaCollection is a mapping between pragma name and the actual value
/// set for that pragma.  This is the main data structure in which pragmas
/// are passed around.  It is a helpful and safe wrapping of an immutable map.
/// It should be impossible to add invalid pragmas to this structure without
/// doing it manually through the underlying map.
type PragmaCollection = PragmaCollection of Map<string,Pragma>
    with
    member x.pmap = match x with PragmaCollection(pc) -> pc
    /// Add a pragma to this collection.
    member x.Add(p:Pragma) =
        PragmaCollection (x.pmap.Add(p.name, p))
    /// Add a pragma to this collection.
    member x.Add(pName:string) =
        x.Add(buildPragma pName [])
    /// Add a pragma to this collection.
    member x.Add(pName:string, value:string) =
        x.Add(buildPragma pName [value])
    /// Add a pragma to this collection.
    member x.Add(pName:string, values:string list) =
        x.Add(buildPragma pName values)
    /// Remove a pragma from this collection.
    member x.Remove(name:string) =
        PragmaCollection (x.pmap.Remove(name))
    /// Merge a list of Pragmas into this collection.
    /// The incoming pragmas will clobber any pragmas set in this collection.
    member x.MergeIn(incoming:Pragma list) =
        incoming
        |> List.fold (fun (pc:Map<string,Pragma>) prag ->
                pc.Add(prag.name, prag))
            x.pmap
        |> PragmaCollection
    /// Merge another PragmaCollection into this one.
    /// The incoming pragmas will clobber any pragmas set in this collection.
    member x.MergeIn(incoming:PragmaCollection) =
        incoming.pmap
        |> Map.fold (fun (pc:Map<string,Pragma>) name prag ->
                pc.Add(name, prag))
            x.pmap
        |> PragmaCollection
    /// Has a pragma been set?
    /// Raises an exception if pName is not a registered pragma.
    member x.ContainsKey(pName:string) =
        validatePragmaName pName
        x.pmap.ContainsKey pName
    /// Get the values associated with a pragma.
    /// Raises an exception is pName is not a registered pragma.
    member x.TryGetValues(pName:string) =
        validatePragmaName pName
        match x.pmap.TryFind pName with
        | Some(p) -> Some(p.args)
        | None -> None
    /// Get a single value associated with a pragma, ignoring any extras.
    /// Raises an exception is pName is not a registered pragma.
    member x.TryGetOne(pName:string) =
        validatePragmaName pName
        match x.TryGetValues pName with
        | Some(v::_) -> Some(v)
        | None | Some([]) -> None
    /// Get a pragma.
    /// Raises an exception is pName is not a registered pragma.
    member x.TryFind(pName:string) =
        validatePragmaName pName
        x.pmap.TryFind pName

let EmptyPragmas = PragmaCollection(Map.empty)